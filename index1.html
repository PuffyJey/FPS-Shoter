<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FPS Mejorado — Demo</title>
  <style>
    :root{font-family:system-ui,Segoe UI,Roboto,Arial}
    html,body{height:100%;margin:0;background:#071025;color:#fff;overflow:hidden}
    #ui{position:fixed;left:12px;top:12px;z-index:40}
    button{padding:.45rem .9rem;border-radius:8px;border:0;background:#1f6feb;color:white;font-weight:700;margin-right:8px;cursor:pointer}
    #game{display:block;width:100vw;height:100vh}
    #minimap{position:fixed;right:12px;top:12px;width:220px;height:220px;background:rgba(0,0,0,0.35);border-radius:10px;padding:8px;z-index:40}
    #status{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;z-index:40}
    #hint{position:fixed;left:50%;transform:translateX(-50%);top:20px;background:rgba(0,0,0,0.55);padding:6px 10px;border-radius:10px;font-weight:600;z-index:40}
    small.gray{opacity:.8;font-size:.85rem;color:#cfeeff}
  </style>
</head>
<body>
  <!--
    FPS Mejorado (single-file)
    - Arroja un requestPointerLock desde un click directo (botón "Iniciar").
    - Maneja teclado en window para asegurar input aun sin foco.
    - Render tipo raycaster con 3 tipos de pared y patrones simples generados en canvas.
    - Minimap y HUD mejorados.
    - Networking: placeholder WS_URL (comentado). Requiere servidor WebSocket que reenvíe mensajes "state".

    Nota: Para que pointer lock funcione en algunos navegadores es mejor servir por HTTPS (Netlify/GitHub Pages están bien).
  -->

  <div id="ui">
    <button id="startBtn">Iniciar / Lock Cursor</button>
    <button id="connectBtn">Conectar (online)</button>
    <button id="spawnBtn">Respawn</button>
    <div style="margin-top:8px"><small class="gray">Controles: clic en Iniciar, mover ratón para girar, WASD, espacio dispara</small></div>
  </div>

  <canvas id="game" tabindex="0"></canvas>
  <canvas id="minimap"></canvas>
  <div id="status">Estado: <span id="stat">offline</span> — Jugadores: <span id="count">1</span> — FPS: <span id="fps">0</span></div>
  <div id="hint">Pulsa <strong>Iniciar</strong> y acepta para bloquear el cursor</div>

<script>
// ---------------------- Config & canvas setup ----------------------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const mini = document.getElementById('minimap');
const mctx = mini.getContext('2d');
let W=innerWidth, H=innerHeight; function resize(){ W=canvas.width=innerWidth; H=canvas.height=innerHeight; mini.width=220; mini.height=220; }
addEventListener('resize', resize); resize();

// ---------------------- Map (varios tiles) ----------------------
// 0 = suelo libre
// 1 = pared piedra, 2 = ladrillo, 3 = metal, 4 = puerta/obs (decor)
const MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,2,0,1],
  [1,0,2,2,0,0,0,0,0,3,3,2,0,1],
  [1,0,2,0,0,0,0,0,0,3,0,0,0,1],
  [1,0,2,0,0,4,4,0,0,3,0,0,0,1],
  [1,0,2,0,0,4,4,0,0,3,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,2,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,2,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,2,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
const MAPW = MAP[0].length, MAPH = MAP.length; const TILE = 64;

// ---------------------- Player & state ----------------------
const player = {x: 2.6 * TILE, y: 2.6 * TILE, ang: Math.PI/4, hp: 100, id: 'me'};
const players = { [player.id]: player };
const bullets = [];

// ---------------------- Raycaster settings ----------------------
const FOV = Math.PI/3; const MAX_DIST = 1200;

// ---------------------- Patterns (procedural textures) ----------------------
function createPattern(type){
  const c = document.createElement('canvas'); c.width=64; c.height=64; const g=c.getContext('2d');
  if(type===1){ // stone
    g.fillStyle='#7f8c8d'; g.fillRect(0,0,64,64);
    for(let i=0;i<200;i++){ g.fillStyle = `rgba(0,0,0,${Math.random()*0.08})`; g.fillRect(Math.random()*64, Math.random()*64, Math.random()*3+1, Math.random()*3+1); }
  } else if(type===2){ // brick
    g.fillStyle='#b33'; g.fillRect(0,0,64,64);
    g.fillStyle='#a22'; for(let y=0;y<64;y+=16){ g.fillRect(0,y,64,12); }
  } else if(type===3){ // metal
    g.fillStyle='#4b6f8a'; g.fillRect(0,0,64,64);
    g.globalAlpha=0.15; for(let i=0;i<6;i++){ g.fillRect(0,i*10,64,4); }
    g.globalAlpha=1;
  } else { g.fillStyle='#222'; g.fillRect(0,0,64,64); }
  return ctx.createPattern(c, 'repeat');
}
const pat1 = createPattern(1), pat2 = createPattern(2), pat3 = createPattern(3);

// ---------------------- Input handling (fixed) ----------------------
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.code==='Space') { e.preventDefault(); shoot(); } });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

// Pointer lock: MUST be triggered by a user gesture (click)
const startBtn = document.getElementById('startBtn');
startBtn.addEventListener('click', ()=>{
  // request lock from the canvas (user gesture)
  canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
  if (canvas.requestPointerLock) {
    canvas.requestPointerLock();
  } else {
    alert('PointerLock no soportado en este navegador. Usa Chrome/Firefox o prueba en otro dispositivo.');
  }
});

function onMouseMove(e){ // only active while pointer locked
  player.ang += e.movementX * 0.0025; // sensitivity
}

document.addEventListener('pointerlockchange', ()=>{
  const locked = document.pointerLockElement === canvas;
  document.getElementById('hint').style.display = locked ? 'none' : 'block';
  if (locked) { document.addEventListener('mousemove', onMouseMove); } else { document.removeEventListener('mousemove', onMouseMove); }
});

// Also allow look by clicking & dragging if pointer lock not available
let dragging=false, lastMouseX=0;
canvas.addEventListener('mousedown', (e)=>{ if(!document.pointerLockElement){ dragging=true; lastMouseX=e.clientX } });
window.addEventListener('mouseup', ()=>{ dragging=false });
window.addEventListener('mousemove', (e)=>{ if(dragging){ const dx=e.clientX-lastMouseX; player.ang += dx*0.005; lastMouseX = e.clientX } });

// ---------------------- Movement & collision ----------------------
function isWallAt(px,py){ const cx=Math.floor(px/TILE), cy=Math.floor(py/TILE); if(cx<0||cy<0||cx>=MAPW||cy>=MAPH) return true; return MAP[cy][cx] > 0; }
function movePlayer(dt){ const speed = 160; let dx=0, dy=0; if(keys['w']){ dx += Math.cos(player.ang)*speed*dt; dy += Math.sin(player.ang)*speed*dt } if(keys['s']){ dx -= Math.cos(player.ang)*speed*dt; dy -= Math.sin(player.ang)*speed*dt } if(keys['a']){ dx += Math.cos(player.ang - Math.PI/2)*speed*dt; dy += Math.sin(player.ang - Math.PI/2)*speed*dt } if(keys['d']){ dx += Math.cos(player.ang + Math.PI/2)*speed*dt; dy += Math.sin(player.ang + Math.PI/2)*speed*dt }
  if(dx===0 && dy===0) return;
  const nx = player.x + dx, ny = player.y + dy, r = 14;
  // basic circle-AABB sweep: test corners
  if(!isWallAt(nx - r, ny - r) && !isWallAt(nx + r, ny - r) && !isWallAt(nx - r, ny + r) && !isWallAt(nx + r, ny + r)){
    player.x = nx; player.y = ny;
  } else {
    // slide on axis separately
    if(!isWallAt(player.x + dx, player.y)) player.x += dx;
    if(!isWallAt(player.x, player.y + dy)) player.y += dy;
  }
}

// ---------------------- Raycasting (improved) ----------------------
function castRay(px,py,ang){ const cos=Math.cos(ang), sin=Math.sin(ang); let dist=0; const step=3; while(dist<MAX_DIST){ dist += step; const rx = px + cos*dist, ry = py + sin*dist; const cx = Math.floor(rx/TILE), cy = Math.floor(ry/TILE); if(cx<0||cy<0||cx>=MAPW||cy>=MAPH) return {dist:MAX_DIST, type:0}; const cell = MAP[cy][cx]; if(cell>0) return {dist, type:cell, hitX:rx, hitY:ry, cx, cy}; } return {dist:MAX_DIST, type:0}; }

function renderScene(){ // sky & floor
  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,H/2);
  g.addColorStop(0,'#86d9ff'); g.addColorStop(1,'#3b7bbf'); ctx.fillStyle = g; ctx.fillRect(0,0,W,H/2);
  // floor gradient
  const g2 = ctx.createLinearGradient(0,H/2,0,H);
  g2.addColorStop(0,'#2b2b2b'); g2.addColorStop(1,'#111'); ctx.fillStyle = g2; ctx.fillRect(0,H/2,W,H/2);

  // vertical slices
  const cols = W; const inv = 1/cols;
  for(let x=0;x<cols;x+=2){
    const rx = (player.ang - FOV/2) + (x*inv)*FOV;
    const hit = castRay(player.x, player.y, rx);
    let dist = hit.dist; if(dist===0) dist=0.0001; const corrected = dist * Math.cos(rx - player.ang);
    const sliceH = Math.min(H, (TILE * 420) / corrected);
    // shading & texture selection by type
    let pattern;
    if(hit.type===1) pattern = pat1; else if(hit.type===2) pattern = pat2; else if(hit.type===3) pattern = pat3; else pattern = null;
    // wall slice
    if(pattern){ ctx.fillStyle = pattern; ctx.save(); ctx.translate(x, (H/2) - sliceH/2); ctx.fillRect(0,0,2,sliceH); ctx.restore(); }
    // darken with distance
    const dark = Math.max(0.2, 1 - (corrected / 900)); ctx.fillStyle = `rgba(0,0,0,${1-dark})`; ctx.fillRect(x, (H/2) - sliceH/2, 2, sliceH);
    // simple vertical line to emphasize
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(x, (H/2) - sliceH/2, 2, 1);
  }

  // crosshair
  ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.fillRect(W/2-1, H/2-9, 2, 18); ctx.fillRect(W/2-9, H/2-1, 18, 2);
}

// ---------------------- Bullets ----------------------
function shoot(){ bullets.push({x: player.x + Math.cos(player.ang)*20, y: player.y + Math.sin(player.ang)*20, ang: player.ang, t:0}); }
function updateBullets(dt){ for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x += Math.cos(b.ang) * 520 * dt; b.y += Math.sin(b.ang) * 520 * dt; b.t += dt; if(isWallAt(b.x,b.y) || b.t > 2.5) bullets.splice(i,1); } }
function drawBullets(){ ctx.fillStyle='yellow'; for(const b of bullets){ // draw near center as tracer
    const dx = b.x - player.x, dy = b.y - player.y, dist = Math.hypot(dx,dy); if(dist < 300) { const sx = W/2 + Math.cos(player.ang)*(dist/2), sy = H/2 + Math.sin(player.ang)*(dist/2); ctx.beginPath(); ctx.arc(sx, sy, 2, 0, Math.PI*2); ctx.fill(); } } }

// ---------------------- Minimap & HUD ----------------------
function drawMinimap(){ const s = mini.width / (MAPW * TILE); mctx.clearRect(0,0,mini.width,mini.height); mctx.fillStyle='#061017'; mctx.fillRect(0,0,mini.width,mini.height);
  for(let y=0;y<MAPH;y++) for(let x=0;x<MAPW;x++){ const t = MAP[y][x]; if(t>0){ if(t===1) mctx.fillStyle='#777'; else if(t===2) mctx.fillStyle='#b33'; else if(t===3) mctx.fillStyle='#49a'; else mctx.fillStyle='#444'; mctx.fillRect(x*TILE*s, y*TILE*s, TILE*s, TILE*s); } }
  // players
  for(const id in players){ const p = players[id]; mctx.fillStyle = (id==='me') ? '#4ef' : '#f55'; mctx.beginPath(); mctx.arc((p.x/TILE)*s, (p.y/TILE)*s, 4, 0, Math.PI*2); mctx.fill(); }
}

// ---------------------- Simple networking placeholder ----------------------
let ws = null; const WS_URL = null; // e.g. 'wss://your-server.example/ws'
const connectBtn = document.getElementById('connectBtn'); connectBtn.addEventListener('click', ()=>{ if(ws) { ws.close(); ws=null; document.getElementById('stat').textContent='offline'; connectBtn.textContent='Conectar (online)'; } else { if(!WS_URL){ alert('WS_URL no configurado. Para multijugador necesitas un servidor WebSocket.'); return; } connectWS(); } });
function connectWS(){ ws = new WebSocket(WS_URL); ws.onopen = ()=>{ document.getElementById('stat').textContent='connected'; connectBtn.textContent='Desconectar'; }; ws.onclose=()=>{ document.getElementById('stat').textContent='offline'; connectBtn.textContent='Conectar (online)'; ws=null; }; ws.onmessage=(m)=>{ try{ const d = JSON.parse(m.data); if(d.type==='state' && d.id && d.id!==player.id){ players[d.id] = players[d.id] || {x:0,y:0,ang:0,id:d.id,hp:100}; Object.assign(players[d.id], {x:d.x,y:d.y,ang:d.ang,hp:d.hp}); } }catch(e){} }; setInterval(()=>{ if(ws && ws.readyState===1) ws.send(JSON.stringify({type:'state',id:player.id,x:player.x,y:player.y,ang:player.ang,hp:player.hp})); }, 120); }

// ---------------------- Game loop & FPS ----------------------
let last = performance.now(); let fpsLast = performance.now(), frames = 0;
function loop(now){ const dt = Math.min(0.05, (now - last)/1000); last = now; movePlayer(dt); updateBullets(dt); renderScene(); drawBullets(); drawMinimap(); updatePlayersUI(); frames++; if(now - fpsLast > 500){ document.getElementById('fps').textContent = Math.round((frames*1000)/(now-fpsLast)); fpsLast = now; frames = 0; } requestAnimationFrame(loop); }
requestAnimationFrame(loop);

function updatePlayersUI(){ // ensure own player in players map
  players[player.id] = player; document.getElementById('count').textContent = Object.keys(players).length; }

// Respawn button
document.getElementById('spawnBtn').addEventListener('click', ()=>{ player.x = 2.6*TILE; player.y = 2.6*TILE; player.hp = 100 });

// When page loads, try focusing canvas so some browsers accept keys
canvas.focus();

// Small accessibility: if pointer lock is not permitted, show a hint; users can still click-drag to turn
if(!('requestPointerLock' in canvas)){
  document.getElementById('hint').textContent = 'PointerLock no disponible — haz click y arrastra para girar, usa WASD para mover.';
}

</script>
</body>
</html>
